module.exports = [
"[project]/node_modules/bezier-easing/src/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * https://github.com/gre/bezier-easing
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 */ // These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
var float32ArraySupported = typeof Float32Array === 'function';
function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
}
function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
}
function C(aA1) {
    return 3.0 * aA1;
}
// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
}
// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}
function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
            aB = currentT;
        } else {
            aA = currentT;
        }
    }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS)
    return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for(var i = 0; i < NEWTON_ITERATIONS; ++i){
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0.0) {
            return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
}
function LinearEasing(x) {
    return x;
}
module.exports = function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error('bezier x values must be in [0, 1] range');
    }
    if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
    }
    // Precompute samples table
    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    for(var i = 0; i < kSplineTableSize; ++i){
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
    function getTForX(aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;
        for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){
            intervalStart += kSampleStepSize;
        }
        --currentSample;
        // Interpolate to provide an initial guess for t
        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0.0) {
            return guessForT;
        } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
    }
    return function BezierEasing(x) {
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
        if (x === 0) {
            return 0;
        }
        if (x === 1) {
            return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
    };
};
}),
"[project]/node_modules/parallax-controller/dist/parallax-controller.esm.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EasingPreset",
    ()=>EasingPreset,
    "Element",
    ()=>Element,
    "Limits",
    ()=>Limits,
    "ParallaxController",
    ()=>ParallaxController,
    "Rect",
    ()=>Rect,
    "RotationUnits",
    ()=>RotationUnits,
    "ScaleUnits",
    ()=>ScaleUnits,
    "Scroll",
    ()=>Scroll,
    "ScrollAxis",
    ()=>ScrollAxis,
    "Units",
    ()=>Units,
    "ValidCSSEffects",
    ()=>ValidCSSEffects,
    "View",
    ()=>View,
    "createId",
    ()=>createId,
    "getProgressAmount",
    ()=>getProgressAmount,
    "isElementInView",
    ()=>isElementInView,
    "parseElementTransitionEffects",
    ()=>parseElementTransitionEffects,
    "parseValueAndUnit",
    ()=>parseValueAndUnit,
    "resetStyles",
    ()=>resetStyles,
    "scaleBetween",
    ()=>scaleBetween,
    "scaleEffectByProgress",
    ()=>scaleEffectByProgress,
    "setElementStyles",
    ()=>setElementStyles,
    "testForPassiveScroll",
    ()=>testForPassiveScroll
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bezier$2d$easing$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bezier-easing/src/index.js [app-ssr] (ecmascript)");
;
var Limits = function Limits(properties) {
    this.startX = properties.startX;
    this.startY = properties.startY;
    this.endX = properties.endX;
    this.endY = properties.endY; // Used to calculate the progress of the element
    this.totalX = this.endX - this.startX;
    this.totalY = this.endY - this.startY; // Used to scale translate effects
    this.startMultiplierX = properties.startMultiplierX || 1;
    this.endMultiplierX = properties.endMultiplierX || 1;
    this.startMultiplierY = properties.startMultiplierY || 1;
    this.endMultiplierY = properties.endMultiplierY || 1;
};
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
var ValidCSSEffects;
(function(ValidCSSEffects) {
    ValidCSSEffects["speed"] = "speed";
    ValidCSSEffects["translateX"] = "translateX";
    ValidCSSEffects["translateY"] = "translateY";
    ValidCSSEffects["rotate"] = "rotate";
    ValidCSSEffects["rotateX"] = "rotateX";
    ValidCSSEffects["rotateY"] = "rotateY";
    ValidCSSEffects["rotateZ"] = "rotateZ";
    ValidCSSEffects["scale"] = "scale";
    ValidCSSEffects["scaleX"] = "scaleX";
    ValidCSSEffects["scaleY"] = "scaleY";
    ValidCSSEffects["scaleZ"] = "scaleZ";
    ValidCSSEffects["opacity"] = "opacity";
})(ValidCSSEffects || (ValidCSSEffects = {}));
var Units;
(function(Units) {
    Units["px"] = "px";
    Units["%"] = "%";
    Units["vh"] = "vh";
    Units["vw"] = "vw";
})(Units || (Units = {}));
var RotationUnits;
(function(RotationUnits) {
    RotationUnits["deg"] = "deg";
    RotationUnits["turn"] = "turn";
    RotationUnits["rad"] = "rad";
})(RotationUnits || (RotationUnits = {}));
var ScaleUnits;
(function(ScaleUnits) {
    ScaleUnits[""] = "";
})(ScaleUnits || (ScaleUnits = {}));
var ScrollAxis;
(function(ScrollAxis) {
    ScrollAxis["vertical"] = "vertical";
    ScrollAxis["horizontal"] = "horizontal";
})(ScrollAxis || (ScrollAxis = {}));
var EasingPreset;
(function(EasingPreset) {
    EasingPreset["ease"] = "ease";
    EasingPreset["easeIn"] = "easeIn";
    EasingPreset["easeOut"] = "easeOut";
    EasingPreset["easeInOut"] = "easeInOut";
    EasingPreset["easeInQuad"] = "easeInQuad";
    EasingPreset["easeInCubic"] = "easeInCubic";
    EasingPreset["easeInQuart"] = "easeInQuart";
    EasingPreset["easeInQuint"] = "easeInQuint";
    EasingPreset["easeInSine"] = "easeInSine";
    EasingPreset["easeInExpo"] = "easeInExpo";
    EasingPreset["easeInCirc"] = "easeInCirc";
    EasingPreset["easeOutQuad"] = "easeOutQuad";
    EasingPreset["easeOutCubic"] = "easeOutCubic";
    EasingPreset["easeOutQuart"] = "easeOutQuart";
    EasingPreset["easeOutQuint"] = "easeOutQuint";
    EasingPreset["easeOutSine"] = "easeOutSine";
    EasingPreset["easeOutExpo"] = "easeOutExpo";
    EasingPreset["easeOutCirc"] = "easeOutCirc";
    EasingPreset["easeInOutQuad"] = "easeInOutQuad";
    EasingPreset["easeInOutCubic"] = "easeInOutCubic";
    EasingPreset["easeInOutQuart"] = "easeInOutQuart";
    EasingPreset["easeInOutQuint"] = "easeInOutQuint";
    EasingPreset["easeInOutSine"] = "easeInOutSine";
    EasingPreset["easeInOutExpo"] = "easeInOutExpo";
    EasingPreset["easeInOutCirc"] = "easeInOutCirc";
    EasingPreset["easeInBack"] = "easeInBack";
    EasingPreset["easeOutBack"] = "easeOutBack";
    EasingPreset["easeInOutBack"] = "easeInOutBack";
})(EasingPreset || (EasingPreset = {}));
/**
 * Creates a unique id to distinguish parallax elements.
 */ var id = 0;
function createId() {
    ++id;
    return id;
}
var Rect = /*#__PURE__*/ function() {
    function Rect(options) {
        var rect = options.el.getBoundingClientRect(); // rect is based on viewport -- must adjust for relative scroll container
        if (options.view.scrollContainer) {
            var scrollRect = options.view.scrollContainer.getBoundingClientRect();
            rect = _extends({}, rect, {
                top: rect.top - scrollRect.top,
                right: rect.right - scrollRect.left,
                bottom: rect.bottom - scrollRect.top,
                left: rect.left - scrollRect.left
            });
        }
        this.height = options.el.offsetHeight;
        this.width = options.el.offsetWidth;
        this.left = rect.left;
        this.right = rect.right;
        this.top = rect.top;
        this.bottom = rect.bottom;
        if (options.rootMargin) {
            this._setRectWithRootMargin(options.rootMargin);
        }
    }
    /**
   * Apply root margin to all properties
   */ var _proto = Rect.prototype;
    _proto._setRectWithRootMargin = function _setRectWithRootMargin(rootMargin) {
        var totalRootY = rootMargin.top + rootMargin.bottom;
        var totalRootX = rootMargin.left + rootMargin.right;
        this.top -= rootMargin.top;
        this.right += rootMargin.right;
        this.bottom += rootMargin.bottom;
        this.left -= rootMargin.left;
        this.height += totalRootY;
        this.width += totalRootX;
    };
    return Rect;
}();
var VALID_UNITS = [
    ScaleUnits[''],
    Units.px,
    Units['%'],
    Units['vh'],
    Units['vw'],
    RotationUnits.deg,
    RotationUnits.turn,
    RotationUnits.rad
];
/**
 * Determines the unit of a string and parses the value
 */ function parseValueAndUnit(str, defaultUnit) {
    if (defaultUnit === void 0) {
        defaultUnit = Units['%'];
    }
    var out = {
        value: 0,
        unit: defaultUnit
    };
    if (typeof str === 'undefined') return out;
    var isValid = typeof str === 'number' || typeof str === 'string';
    if (!isValid) {
        throw new Error('Invalid value provided. Must provide a value as a string or number');
    }
    str = String(str);
    out.value = parseFloat(str); // @ts-ignore
    out.unit = str.match(/[\d.\-+]*\s*(.*)/)[1] || defaultUnit; // @ts-expect-error
    var isValidUnit = VALID_UNITS.includes(out.unit);
    if (!isValidUnit) {
        throw new Error('Invalid unit provided.');
    }
    return out;
}
var easingPresets = {
    ease: [
        0.25,
        0.1,
        0.25,
        1.0
    ],
    easeIn: [
        0.42,
        0.0,
        1.0,
        1.0
    ],
    easeOut: [
        0.0,
        0.0,
        0.58,
        1.0
    ],
    easeInOut: [
        0.42,
        0.0,
        0.58,
        1.0
    ],
    /* Ease IN curves */ easeInQuad: [
        0.55,
        0.085,
        0.68,
        0.53
    ],
    easeInCubic: [
        0.55,
        0.055,
        0.675,
        0.19
    ],
    easeInQuart: [
        0.895,
        0.03,
        0.685,
        0.22
    ],
    easeInQuint: [
        0.755,
        0.05,
        0.855,
        0.06
    ],
    easeInSine: [
        0.47,
        0.0,
        0.745,
        0.715
    ],
    easeInExpo: [
        0.95,
        0.05,
        0.795,
        0.035
    ],
    easeInCirc: [
        0.6,
        0.04,
        0.98,
        0.335
    ],
    /* Ease Out Curves */ easeOutQuad: [
        0.25,
        0.46,
        0.45,
        0.94
    ],
    easeOutCubic: [
        0.215,
        0.61,
        0.355,
        1.0
    ],
    easeOutQuart: [
        0.165,
        0.84,
        0.44,
        1.0
    ],
    easeOutQuint: [
        0.23,
        1.0,
        0.32,
        1.0
    ],
    easeOutSine: [
        0.39,
        0.575,
        0.565,
        1.0
    ],
    easeOutExpo: [
        0.19,
        1.0,
        0.22,
        1.0
    ],
    easeOutCirc: [
        0.075,
        0.82,
        0.165,
        1.0
    ],
    /* Ease IN Out Curves */ easeInOutQuad: [
        0.455,
        0.03,
        0.515,
        0.955
    ],
    easeInOutCubic: [
        0.645,
        0.045,
        0.355,
        1.0
    ],
    easeInOutQuart: [
        0.77,
        0.0,
        0.175,
        1.0
    ],
    easeInOutQuint: [
        0.86,
        0.0,
        0.07,
        1.0
    ],
    easeInOutSine: [
        0.445,
        0.05,
        0.55,
        0.95
    ],
    easeInOutExpo: [
        1.0,
        0.0,
        0.0,
        1.0
    ],
    easeInOutCirc: [
        0.785,
        0.135,
        0.15,
        0.86
    ],
    /* Ease Bounce Curves */ easeInBack: [
        0.6,
        -0.28,
        0.735,
        0.045
    ],
    easeOutBack: [
        0.175,
        0.885,
        0.32,
        1.275
    ],
    easeInOutBack: [
        0.68,
        -0.55,
        0.265,
        1.55
    ]
};
function createEasingFunction(easing) {
    if (Array.isArray(easing)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bezier$2d$easing$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(easing[0], easing[1], easing[2], easing[3]);
    }
    if (typeof easing === 'string' && typeof easingPresets[easing] !== 'undefined') {
        var params = easingPresets[easing];
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bezier$2d$easing$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(params[0], params[1], params[2], params[3]);
    }
    return;
}
var PARALLAX_EFFECTS = /*#__PURE__*/ Object.values(ValidCSSEffects);
var MAP_EFFECT_TO_DEFAULT_UNIT = {
    speed: 'px',
    translateX: '%',
    translateY: '%',
    rotate: 'deg',
    rotateX: 'deg',
    rotateY: 'deg',
    rotateZ: 'deg',
    scale: '',
    scaleX: '',
    scaleY: '',
    scaleZ: '',
    opacity: ''
};
/**
 * Takes a parallax element effects and parses the properties to get the start and end values and units.
 */ function parseElementTransitionEffects(props, scrollAxis) {
    var parsedEffects = {};
    PARALLAX_EFFECTS.forEach(function(key) {
        var defaultValue = MAP_EFFECT_TO_DEFAULT_UNIT[key]; // If the provided type is a number, this must be the speed prop
        // in which case we need to construct the proper translate config
        if (typeof (props == null ? void 0 : props[key]) === 'number') {
            var value = props == null ? void 0 : props[key];
            var startSpeed = (value || 0) * 10 + "px";
            var endSpeed = (value || 0) * -10 + "px";
            var startParsed = parseValueAndUnit(startSpeed);
            var endParsed = parseValueAndUnit(endSpeed);
            var speedConfig = {
                start: startParsed.value,
                end: endParsed.value,
                unit: startParsed.unit
            }; // Manually set translate y value
            if (scrollAxis === ScrollAxis.vertical) {
                parsedEffects.translateY = speedConfig;
            } // Manually set translate y value
            if (scrollAxis === ScrollAxis.horizontal) {
                parsedEffects.translateX = speedConfig;
            }
        } // The rest are standard effect being parsed
        if (Array.isArray(props == null ? void 0 : props[key])) {
            var _value = props == null ? void 0 : props[key];
            if (typeof _value[0] !== 'undefined' && typeof _value[1] !== 'undefined') {
                var _startParsed = parseValueAndUnit(_value == null ? void 0 : _value[0], defaultValue);
                var _endParsed = parseValueAndUnit(_value == null ? void 0 : _value[1], defaultValue);
                var easing = createEasingFunction(_value == null ? void 0 : _value[2]);
                parsedEffects[key] = {
                    start: _startParsed.value,
                    end: _endParsed.value,
                    unit: _startParsed.unit,
                    easing: easing
                };
                if (_startParsed.unit !== _endParsed.unit) {
                    throw new Error('Must provide matching units for the min and max offset values of each axis.');
                }
            }
        }
    });
    return parsedEffects;
}
/**
 * Returns the percent (0 - 100) moved based on position in the viewport
 */ function getProgressAmount(/*
 * The start value from cache
 */ start, /*
 * total dist the element has to move to be 100% complete (view width/height + element width/height)
 */ totalDist, /*
 * Current scroll value
 */ currentScroll, /*
 * an optional easing function to apply
 */ easing) {
    // adjust cached value
    var startAdjustedScroll = currentScroll - start; // Amount the element has moved based on current and total distance to move
    var amount = startAdjustedScroll / totalDist; // Apply bezier easing if provided
    if (easing) {
        amount = easing(amount);
    }
    return amount;
}
/**
 * Takes two values (start, end) and returns whether the current scroll is within range
 * @param {number} start - start of scroll (x/y)
 * @param {number} end - end of scroll (x/y)
 * @param {number} scroll - current scroll (x/y)
 * @return {boolean} isInView
 */ function isElementInView(start, end, scroll) {
    var isInView = scroll >= start && scroll <= end;
    return isInView;
}
// Scale between AKA normalize
function scaleBetween(value, newMin, newMax, oldMin, oldMax) {
    return (newMax - newMin) * (value - oldMin) / (oldMax - oldMin) + newMin;
}
/**
 * Scales a start and end value of an effect based on percent moved and easing function
 */ function scaleEffectByProgress(effect, progress) {
    var value = scaleBetween(typeof effect.easing === 'function' ? effect.easing(progress) : progress, (effect == null ? void 0 : effect.start) || 0, (effect == null ? void 0 : effect.end) || 0, 0, 1);
    return {
        value: value,
        unit: effect == null ? void 0 : effect.unit
    };
}
var TRANSFORM_EFFECTS = /*#__PURE__*/ Object.values(ValidCSSEffects).filter(function(v) {
    return v !== 'opacity';
});
function setWillChangeStyles(el, effects) {
    var keys = Object.keys(effects);
    var hasOpacity = keys.includes('opacity');
    var willChange = "transform" + (hasOpacity ? ',opacity' : '');
    el.style.willChange = willChange;
}
function setElementStyles(effects, progress, el) {
    if (!el) return;
    var transform = getTransformStyles(effects, progress);
    var opacity = getOpacityStyles(effects, progress);
    el.style.transform = transform;
    el.style.opacity = opacity;
}
function getOpacityStyles(effects, progress) {
    var scaledOpacity = effects['opacity'] && scaleEffectByProgress(effects['opacity'], progress);
    if (typeof scaledOpacity === 'undefined' || typeof scaledOpacity.value === 'undefined' || typeof scaledOpacity.unit === 'undefined') {
        return '';
    }
    var styleStr = "" + scaledOpacity.value;
    return styleStr;
}
function getTransformStyles(effects, progress) {
    var transform = TRANSFORM_EFFECTS.reduce(function(acc, key) {
        var scaledEffect = effects[key] && scaleEffectByProgress(effects[key], progress);
        if (typeof scaledEffect === 'undefined' || typeof scaledEffect.value === 'undefined' || typeof scaledEffect.unit === 'undefined') {
            return acc;
        }
        var styleStr = key + "(" + scaledEffect.value + scaledEffect.unit + ")";
        return acc + styleStr;
    }, '');
    return transform;
}
/**
 * Takes a parallax element and removes parallax offset styles.
 * @param {object} element
 */ function resetStyles(element) {
    var el = element.el;
    if (!el) return;
    el.style.transform = '';
    el.style.opacity = '';
}
function createLimitsForRelativeElements(rect, view, scroll, shouldAlwaysCompleteAnimation) {
    var startY = rect.top - view.height;
    var startX = rect.left - view.width;
    var endY = rect.bottom;
    var endX = rect.right; // add scroll
    startX += scroll.x;
    endX += scroll.x;
    startY += scroll.y;
    endY += scroll.y;
    if (shouldAlwaysCompleteAnimation) {
        if (scroll.y + rect.top < view.height) {
            startY = 0;
        }
        if (scroll.x + rect.left < view.width) {
            startX = 0;
        }
        if (endY > view.scrollHeight - view.height) {
            endY = view.scrollHeight - view.height;
        }
        if (endX > view.scrollWidth - view.width) {
            endX = view.scrollWidth - view.width;
        }
    }
    var limits = new Limits({
        startX: startX,
        startY: startY,
        endX: endX,
        endY: endY
    });
    return limits;
}
function getTranslateScalar(startTranslatePx, endTranslatePx, totalDist) {
    var slow = endTranslatePx > startTranslatePx; // calculating necessary scale to increase translations
    var totalAbsOff = (Math.abs(startTranslatePx) + Math.abs(endTranslatePx)) * (slow ? -1 : 1);
    var totalDistTrue = totalDist + totalAbsOff; // Determine multiple to scale by, only values greater than 1
    var scale = Math.max(totalDist / totalDistTrue, 1);
    return scale;
}
/**
 * Return the start and end pixel values for an elements translations
 */ function getStartEndValueInPx(translate, elementSize) {
    var start = translate.start, end = translate.end, unit = translate.unit;
    if (unit === '%') {
        var scale = elementSize / 100;
        start = start * scale;
        end = end * scale;
    }
    if (unit === 'vw') {
        var startScale = start / 100;
        var endScale = end / 100;
        start = window.innerWidth * startScale;
        end = window.innerWidth * endScale;
    }
    if (unit === 'vh') {
        var _startScale = start / 100;
        var _endScale = end / 100;
        start = window.innerHeight * _startScale;
        end = window.innerHeight * _endScale;
    }
    return {
        start: start,
        end: end
    };
}
var DEFAULT_VALUE = {
    start: 0,
    end: 0,
    unit: ''
};
function createLimitsWithTranslationsForRelativeElements(rect, view, effects, scroll, scrollAxis, shouldAlwaysCompleteAnimation) {
    // get start and end accounting for percent effects
    var translateX = effects.translateX || DEFAULT_VALUE;
    var translateY = effects.translateY || DEFAULT_VALUE;
    var _getStartEndValueInPx = getStartEndValueInPx(translateX, rect.width), startTranslateXPx = _getStartEndValueInPx.start, endTranslateXPx = _getStartEndValueInPx.end;
    var _getStartEndValueInPx2 = getStartEndValueInPx(translateY, rect.height), startTranslateYPx = _getStartEndValueInPx2.start, endTranslateYPx = _getStartEndValueInPx2.end; // default starting values
    var startY = rect.top - view.height;
    var startX = rect.left - view.width;
    var endY = rect.bottom;
    var endX = rect.right;
    var startMultiplierY = 1;
    var endMultiplierY = 1;
    if (scrollAxis === ScrollAxis.vertical) {
        startMultiplierY = getTranslateScalar(startTranslateYPx, endTranslateYPx, view.height + rect.height);
        endMultiplierY = startMultiplierY;
    }
    var startMultiplierX = 1;
    var endMultiplierX = 1;
    if (scrollAxis === ScrollAxis.horizontal) {
        startMultiplierX = getTranslateScalar(startTranslateXPx, endTranslateXPx, view.width + rect.width);
        endMultiplierX = startMultiplierX;
    } // Apply the scale to initial values
    if (startTranslateYPx < 0) {
        startY = startY + startTranslateYPx * startMultiplierY;
    }
    if (endTranslateYPx > 0) {
        endY = endY + endTranslateYPx * endMultiplierY;
    }
    if (startTranslateXPx < 0) {
        startX = startX + startTranslateXPx * startMultiplierX;
    }
    if (endTranslateXPx > 0) {
        endX = endX + endTranslateXPx * endMultiplierX;
    } // add scroll
    startX += scroll.x;
    endX += scroll.x;
    startY += scroll.y;
    endY += scroll.y; // NOTE: please refactor and isolate this :(
    if (shouldAlwaysCompleteAnimation) {
        var topBeginsInView = scroll.y + rect.top < view.height;
        var leftBeginsInView = scroll.x + rect.left < view.width;
        var bottomEndsInView = scroll.y + rect.bottom > view.scrollHeight - view.height;
        var rightEndsInView = scroll.x + rect.right > view.scrollWidth - view.height;
        if (topBeginsInView && bottomEndsInView) {
            startMultiplierY = 1;
            endMultiplierY = 1;
            startY = 0;
            endY = view.scrollHeight - view.height;
        }
        if (leftBeginsInView && rightEndsInView) {
            startMultiplierX = 1;
            endMultiplierX = 1;
            startX = 0;
            endX = view.scrollWidth - view.width;
        }
        if (!topBeginsInView && bottomEndsInView) {
            startY = rect.top - view.height + scroll.y;
            endY = view.scrollHeight - view.height;
            var totalDist = endY - startY;
            startMultiplierY = getTranslateScalar(startTranslateYPx, endTranslateYPx, totalDist);
            endMultiplierY = 1;
            if (startTranslateYPx < 0) {
                startY = startY + startTranslateYPx * startMultiplierY;
            }
        }
        if (!leftBeginsInView && rightEndsInView) {
            startX = rect.left - view.width + scroll.x;
            endX = view.scrollWidth - view.width;
            var _totalDist = endX - startX;
            startMultiplierX = getTranslateScalar(startTranslateXPx, endTranslateXPx, _totalDist);
            endMultiplierX = 1;
            if (startTranslateXPx < 0) {
                startX = startX + startTranslateXPx * startMultiplierX;
            }
        }
        if (topBeginsInView && !bottomEndsInView) {
            startY = 0;
            endY = rect.bottom + scroll.y;
            var _totalDist2 = endY - startY;
            startMultiplierY = 1;
            endMultiplierY = getTranslateScalar(startTranslateYPx, endTranslateYPx, _totalDist2);
            if (endTranslateYPx > 0) {
                endY = endY + endTranslateYPx * endMultiplierY;
            }
        }
        if (leftBeginsInView && !rightEndsInView) {
            startX = 0;
            endX = rect.right + scroll.x;
            var _totalDist3 = endX - startX;
            startMultiplierX = 1;
            endMultiplierX = getTranslateScalar(startTranslateXPx, endTranslateXPx, _totalDist3);
            if (endTranslateXPx > 0) {
                endX = endX + endTranslateXPx * endMultiplierX;
            }
        }
    }
    var limits = new Limits({
        startX: startX,
        startY: startY,
        endX: endX,
        endY: endY,
        startMultiplierX: startMultiplierX,
        endMultiplierX: endMultiplierX,
        startMultiplierY: startMultiplierY,
        endMultiplierY: endMultiplierY
    });
    return limits;
}
function scaleTranslateEffectsForSlowerScroll(effects, limits) {
    var effectsCopy = _extends({}, effects);
    if (effectsCopy.translateX) {
        effectsCopy.translateX = _extends({}, effects.translateX, {
            start: effectsCopy.translateX.start * limits.startMultiplierX,
            end: effectsCopy.translateX.end * limits.endMultiplierX
        });
    }
    if (effectsCopy.translateY) {
        effectsCopy.translateY = _extends({}, effects.translateY, {
            start: effectsCopy.translateY.start * limits.startMultiplierY,
            end: effectsCopy.translateY.end * limits.endMultiplierY
        });
    }
    return effectsCopy;
}
function getShouldScaleTranslateEffects(props, effects, scrollAxis) {
    if (props.rootMargin || props.targetElement || props.shouldDisableScalingTranslations) {
        return false;
    }
    if (!!effects.translateX && scrollAxis === ScrollAxis.horizontal || !!effects.translateY && scrollAxis === ScrollAxis.vertical) {
        return true;
    }
    return false;
}
var clamp = function clamp(num, min, max) {
    return Math.min(Math.max(num, min), max);
};
var Element = /*#__PURE__*/ function() {
    function Element(options) {
        this.el = options.el;
        this.props = options.props;
        this.scrollAxis = options.scrollAxis;
        this.disabledParallaxController = options.disabledParallaxController || false;
        this.id = createId();
        this.effects = parseElementTransitionEffects(this.props, this.scrollAxis);
        this.isInView = null;
        this.progress = 0;
        this._setElementEasing(options.props.easing);
        setWillChangeStyles(options.el, this.effects);
    }
    var _proto = Element.prototype;
    _proto.updateProps = function updateProps(nextProps) {
        this.props = _extends({}, this.props, nextProps);
        this.effects = parseElementTransitionEffects(nextProps, this.scrollAxis);
        this._setElementEasing(nextProps.easing);
        return this;
    };
    _proto.setCachedAttributes = function setCachedAttributes(view, scroll) {
        // NOTE: Must reset styles before getting the rect, as it might impact the natural position
        resetStyles(this);
        this.rect = new Rect({
            el: this.props.targetElement || this.el,
            rootMargin: this.props.rootMargin,
            view: view
        });
        var shouldScaleTranslateEffects = getShouldScaleTranslateEffects(this.props, this.effects, this.scrollAxis);
        if (typeof this.props.startScroll === 'number' && typeof this.props.endScroll === 'number') {
            this.limits = new Limits({
                startX: this.props.startScroll,
                startY: this.props.startScroll,
                endX: this.props.endScroll,
                endY: this.props.endScroll
            }); // Undo the reset -- place it back at current position with styles
            this._setElementStyles();
            return this;
        }
        if (shouldScaleTranslateEffects) {
            this.limits = createLimitsWithTranslationsForRelativeElements(this.rect, view, this.effects, scroll, this.scrollAxis, this.props.shouldAlwaysCompleteAnimation);
            this.scaledEffects = scaleTranslateEffectsForSlowerScroll(this.effects, this.limits);
        } else {
            this.limits = createLimitsForRelativeElements(this.rect, view, scroll, this.props.shouldAlwaysCompleteAnimation);
        } // Undo the reset -- place it back at current position with styles
        this._setElementStyles();
        return this;
    };
    _proto._updateElementIsInView = function _updateElementIsInView(nextIsInView) {
        // NOTE: Check if this is the first change to make sure onExit isn't called
        var isFirstChange = this.isInView === null;
        if (nextIsInView !== this.isInView) {
            if (nextIsInView) {
                this.props.onEnter && this.props.onEnter(this);
            } else if (!isFirstChange) {
                this._setFinalProgress();
                this._setElementStyles();
                this.props.onExit && this.props.onExit(this);
            }
        }
        this.isInView = nextIsInView;
    };
    _proto._setFinalProgress = function _setFinalProgress() {
        var finalProgress = clamp(Math.round(this.progress), 0, 1);
        this._updateElementProgress(finalProgress);
    };
    _proto._setElementStyles = function _setElementStyles() {
        if (this.props.disabled || this.disabledParallaxController) return;
        var effects = this.scaledEffects || this.effects;
        setElementStyles(effects, this.progress, this.el);
    };
    _proto._updateElementProgress = function _updateElementProgress(nextProgress) {
        this.progress = nextProgress;
        this.props.onProgressChange && this.props.onProgressChange(this.progress);
        this.props.onChange && this.props.onChange(this);
    };
    _proto._setElementEasing = function _setElementEasing(easing) {
        this.easing = createEasingFunction(easing);
    };
    _proto.updateElementOptions = function updateElementOptions(options) {
        this.scrollAxis = options.scrollAxis;
        this.disabledParallaxController = options.disabledParallaxController || false;
    };
    _proto.updatePosition = function updatePosition(scroll) {
        if (!this.limits) return this;
        var isVertical = this.scrollAxis === ScrollAxis.vertical;
        var isFirstChange = this.isInView === null; // based on scroll axis
        var start = isVertical ? this.limits.startY : this.limits.startX;
        var end = isVertical ? this.limits.endY : this.limits.endX;
        var total = isVertical ? this.limits.totalY : this.limits.totalX;
        var s = isVertical ? scroll.y : scroll.x; // check if in view
        var nextIsInView = isElementInView(start, end, s);
        this._updateElementIsInView(nextIsInView); // set the progress if in view or this is the first change
        if (nextIsInView) {
            var nextProgress = getProgressAmount(start, total, s, this.easing);
            this._updateElementProgress(nextProgress);
            this._setElementStyles();
        } else if (isFirstChange) {
            // NOTE: this._updateElementProgress -- dont use this because it will trigger onChange
            this.progress = clamp(Math.round(getProgressAmount(start, total, s, this.easing)), 0, 1);
            this._setElementStyles();
        }
        return this;
    };
    return Element;
}();
var View = /*#__PURE__*/ function() {
    function View(config) {
        this.scrollContainer = config.scrollContainer;
        this.width = config.width;
        this.height = config.height;
        this.scrollHeight = config.scrollHeight;
        this.scrollWidth = config.scrollWidth;
    }
    var _proto = View.prototype;
    _proto.hasChanged = function hasChanged(params) {
        if (params.width !== this.width || params.height !== this.height || params.scrollWidth !== this.scrollWidth || params.scrollHeight !== this.scrollHeight) {
            return true;
        }
        return false;
    };
    _proto.setSize = function setSize(params) {
        this.width = params.width;
        this.height = params.height;
        this.scrollHeight = params.scrollHeight;
        this.scrollWidth = params.scrollWidth;
        return this;
    };
    return View;
}();
var Scroll = /*#__PURE__*/ function() {
    function Scroll(x, y) {
        this.x = x;
        this.y = y;
        this.dx = 0;
        this.dy = 0;
    }
    var _proto = Scroll.prototype;
    _proto.setScroll = function setScroll(x, y) {
        this.dx = x - this.x;
        this.dy = y - this.y;
        this.x = x;
        this.y = y;
        return this;
    };
    return Scroll;
}();
function testForPassiveScroll() {
    var supportsPassiveOption = false;
    try {
        var opts = Object.defineProperty({}, 'passive', {
            get: function get() {
                supportsPassiveOption = true;
                return true;
            }
        }); // @ts-expect-error
        window.addEventListener('test', null, opts); // @ts-expect-error
        window.removeEventListener('test', null, opts);
    } catch (e) {}
    return supportsPassiveOption;
}
/**
 * -------------------------------------------------------
 * Parallax Controller
 * -------------------------------------------------------
 *
 * The global controller for setting up and managing a scroll view of elements.
 *
 */ var ParallaxController = /*#__PURE__*/ function() {
    function ParallaxController(_ref) {
        var _ref$scrollAxis = _ref.scrollAxis, scrollAxis = _ref$scrollAxis === void 0 ? ScrollAxis.vertical : _ref$scrollAxis, scrollContainer = _ref.scrollContainer, _ref$disabled = _ref.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled;
        this.disabled = disabled;
        this.scrollAxis = scrollAxis; // All parallax elements to be updated
        this.elements = [];
        this._hasScrollContainer = !!scrollContainer;
        this.viewEl = scrollContainer != null ? scrollContainer : window; // Scroll and View
        var _this$_getScrollPosit = this._getScrollPosition(), x = _this$_getScrollPosit[0], y = _this$_getScrollPosit[1];
        this.scroll = new Scroll(x, y);
        this.view = new View({
            width: 0,
            height: 0,
            scrollWidth: 0,
            scrollHeight: 0,
            scrollContainer: this._hasScrollContainer ? scrollContainer : undefined
        }); // Ticking
        this._ticking = false; // Passive support
        this._supportsPassive = testForPassiveScroll(); // Bind methods to class
        this._bindAllMethods(); // If this is initialized disabled, don't do anything below.
        if (this.disabled) return;
        this._addListeners(this.viewEl);
        this._addResizeObserver();
        this._setViewSize();
    }
    /**
   * Static method to instantiate the ParallaxController.
   * @returns {Class} ParallaxController
   */ ParallaxController.init = function init(options) {
        var hasWindow = ("TURBOPACK compile-time value", "undefined") !== 'undefined';
        if ("TURBOPACK compile-time truthy", 1) {
            throw new Error('Looks like ParallaxController.init() was called on the server. This method must be called on the client.');
        }
        return new ParallaxController(options);
    };
    var _proto = ParallaxController.prototype;
    _proto._bindAllMethods = function _bindAllMethods() {
        var _this = this;
        [
            '_addListeners',
            '_removeListeners',
            '_getScrollPosition',
            '_handleScroll',
            '_handleUpdateCache',
            '_updateAllElements',
            '_updateElementPosition',
            '_setViewSize',
            '_addResizeObserver',
            '_checkIfViewHasChanged',
            '_getViewParams',
            'getElements',
            'createElement',
            'removeElementById',
            'resetElementStyles',
            'updateElementPropsById',
            'update',
            'updateScrollContainer',
            'destroy'
        ].forEach(function(method) {
            // @ts-expect-error
            _this[method] = _this[method].bind(_this);
        });
    };
    _proto._addListeners = function _addListeners(el) {
        el.addEventListener('scroll', this._handleScroll, this._supportsPassive ? {
            passive: true
        } : false);
        window.addEventListener('resize', this._handleUpdateCache, false);
        window.addEventListener('blur', this._handleUpdateCache, false);
        window.addEventListener('focus', this._handleUpdateCache, false);
        window.addEventListener('load', this._handleUpdateCache, false);
    };
    _proto._removeListeners = function _removeListeners(el) {
        var _this$_resizeObserver;
        el.removeEventListener('scroll', this._handleScroll, false);
        window.removeEventListener('resize', this._handleUpdateCache, false);
        window.removeEventListener('blur', this._handleUpdateCache, false);
        window.removeEventListener('focus', this._handleUpdateCache, false);
        window.removeEventListener('load', this._handleUpdateCache, false);
        (_this$_resizeObserver = this._resizeObserver) == null ? void 0 : _this$_resizeObserver.disconnect();
    };
    _proto._addResizeObserver = function _addResizeObserver() {
        var _this2 = this;
        try {
            var observedEl = this._hasScrollContainer ? this.viewEl : document.documentElement;
            this._resizeObserver = new ResizeObserver(function() {
                return _this2.update();
            });
            this._resizeObserver.observe(observedEl);
        } catch (e) {
            console.warn('Failed to create the resize observer in the ParallaxContoller');
        }
    };
    _proto._getScrollPosition = function _getScrollPosition() {
        // Save current scroll
        // Supports IE 9 and up.
        var nx = this._hasScrollContainer ? this.viewEl.scrollLeft : window.pageXOffset;
        var ny = this._hasScrollContainer ? this.viewEl.scrollTop : window.pageYOffset;
        return [
            nx,
            ny
        ];
    };
    _proto._handleScroll = function _handleScroll() {
        var _this$elements;
        var _this$_getScrollPosit2 = this._getScrollPosition(), nx = _this$_getScrollPosit2[0], ny = _this$_getScrollPosit2[1];
        this.scroll.setScroll(nx, ny); // Only called if the last animation request has been
        // completed and there are parallax elements to update
        if (!this._ticking && ((_this$elements = this.elements) == null ? void 0 : _this$elements.length) > 0) {
            this._ticking = true; // @ts-ignore
            window.requestAnimationFrame(this._updateAllElements);
        }
    };
    _proto._handleUpdateCache = function _handleUpdateCache() {
        this._setViewSize();
        this._updateAllElements({
            updateCache: true
        });
    };
    _proto._updateAllElements = function _updateAllElements(_temp) {
        var _this3 = this;
        var _ref2 = _temp === void 0 ? {} : _temp, updateCache = _ref2.updateCache;
        if (this.elements) {
            this.elements.forEach(function(element) {
                if (updateCache) {
                    element.setCachedAttributes(_this3.view, _this3.scroll);
                }
                _this3._updateElementPosition(element);
            });
        } // reset ticking so more animations can be called
        this._ticking = false;
    };
    _proto._updateElementPosition = function _updateElementPosition(element) {
        if (element.props.disabled || this.disabled) return;
        element.updatePosition(this.scroll);
    };
    _proto._getViewParams = function _getViewParams() {
        if (this._hasScrollContainer) {
            // @ts-expect-error
            var _width = this.viewEl.offsetWidth; // @ts-expect-error
            var _height = this.viewEl.offsetHeight; // @ts-expect-error
            var _scrollHeight = this.viewEl.scrollHeight; // @ts-expect-error
            var _scrollWidth = this.viewEl.scrollWidth;
            return this.view.setSize({
                width: _width,
                height: _height,
                scrollHeight: _scrollHeight,
                scrollWidth: _scrollWidth
            });
        }
        var html = document.documentElement;
        var width = window.innerWidth || html.clientWidth;
        var height = window.innerHeight || html.clientHeight;
        var scrollHeight = html.scrollHeight;
        var scrollWidth = html.scrollWidth;
        return {
            width: width,
            height: height,
            scrollHeight: scrollHeight,
            scrollWidth: scrollWidth
        };
    };
    _proto._setViewSize = function _setViewSize() {
        return this.view.setSize(this._getViewParams());
    };
    _proto._checkIfViewHasChanged = function _checkIfViewHasChanged() {
        return this.view.hasChanged(this._getViewParams());
    };
    _proto.getElements = function getElements() {
        return this.elements;
    };
    _proto.createElement = function createElement(options) {
        var newElement = new Element(_extends({}, options, {
            scrollAxis: this.scrollAxis,
            disabledParallaxController: this.disabled
        }));
        newElement.setCachedAttributes(this.view, this.scroll);
        this.elements = this.elements ? [].concat(this.elements, [
            newElement
        ]) : [
            newElement
        ];
        this._updateElementPosition(newElement); // NOTE: This checks if the view has changed then update the controller and all elements if it has
        // This shouldn't always be necessary with a resize observer watching the view element
        // but there seems to be cases where the resize observer does not catch and update.
        if (this._checkIfViewHasChanged()) {
            this.update();
        }
        return newElement;
    };
    _proto.removeElementById = function removeElementById(id) {
        if (!this.elements) return;
        this.elements = this.elements.filter(function(el) {
            return el.id !== id;
        });
    };
    _proto.updateElementPropsById = function updateElementPropsById(id, props) {
        if (this.elements) {
            this.elements = this.elements.map(function(el) {
                if (el.id === id) {
                    return el.updateProps(props);
                }
                return el;
            });
        }
        this.update();
    };
    _proto.resetElementStyles = function resetElementStyles(element) {
        resetStyles(element);
    };
    _proto.update = function update() {
        // Save the latest scroll position because window.scroll
        // may be called and the handle scroll event may not be called.
        var _this$_getScrollPosit3 = this._getScrollPosition(), nx = _this$_getScrollPosit3[0], ny = _this$_getScrollPosit3[1];
        this.scroll.setScroll(nx, ny);
        this._setViewSize();
        this._updateAllElements({
            updateCache: true
        });
    };
    _proto.updateScrollContainer = function updateScrollContainer(el) {
        // remove existing listeners with current el first
        this._removeListeners(this.viewEl);
        this.viewEl = el;
        this._hasScrollContainer = !!el;
        this.view = new View({
            width: 0,
            height: 0,
            scrollWidth: 0,
            scrollHeight: 0,
            scrollContainer: el
        });
        this._setViewSize();
        this._addListeners(this.viewEl);
        this._updateAllElements({
            updateCache: true
        });
    };
    _proto.disableParallaxController = function disableParallaxController() {
        this.disabled = true; // remove listeners
        this._removeListeners(this.viewEl); // reset all styles
        if (this.elements) {
            this.elements.forEach(function(element) {
                return resetStyles(element);
            });
        }
    };
    _proto.enableParallaxController = function enableParallaxController() {
        var _this4 = this;
        this.disabled = false;
        if (this.elements) {
            this.elements.forEach(function(element) {
                return element.updateElementOptions({
                    disabledParallaxController: false,
                    scrollAxis: _this4.scrollAxis
                });
            });
        } // add back listeners
        this._addListeners(this.viewEl);
        this._addResizeObserver();
        this._setViewSize();
    };
    _proto.disableAllElements = function disableAllElements() {
        console.warn('deprecated: use disableParallaxController() instead');
        if (this.elements) {
            this.elements = this.elements.map(function(el) {
                return el.updateProps({
                    disabled: true
                });
            });
        }
        this.update();
    };
    _proto.enableAllElements = function enableAllElements() {
        console.warn('deprecated: use enableParallaxController() instead');
        if (this.elements) {
            this.elements = this.elements.map(function(el) {
                return el.updateProps({
                    disabled: false
                });
            });
        }
        this.update();
    };
    _proto.destroy = function destroy() {
        this._removeListeners(this.viewEl);
        if (this.elements) {
            this.elements.forEach(function(element) {
                return resetStyles(element);
            });
        } // @ts-expect-error
        this.elements = undefined;
    };
    return ParallaxController;
}();
;
 //# sourceMappingURL=parallax-controller.esm.js.map
}),
"[project]/node_modules/react-scroll-parallax/dist/index.mjs [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Parallax",
    ()=>Parallax,
    "ParallaxBanner",
    ()=>ParallaxBanner,
    "ParallaxBannerLayer",
    ()=>ParallaxBannerLayer,
    "ParallaxContext",
    ()=>ParallaxContext,
    "ParallaxProvider",
    ()=>ParallaxProvider,
    "useParallax",
    ()=>useParallax,
    "useParallaxController",
    ()=>useParallaxController
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parallax$2d$controller$2f$dist$2f$parallax$2d$controller$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/parallax-controller/dist/parallax-controller.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
;
;
//#region src/utils/removeUndefinedObjectKeys.ts
function removeUndefinedObjectKeys(obj) {
    Object.keys(obj).forEach((key)=>obj[key] === void 0 && delete obj[key]);
    return obj;
}
//#endregion
//#region src/helpers/getIsolatedParallaxProps.ts
function getIsolatedParallaxProps(props) {
    const { disabled, easing, endScroll, onChange, onEnter, onExit, onProgressChange, opacity, rootMargin, rotate, rotateX, rotateY, rotateZ, scale, scaleX, scaleY, scaleZ, shouldAlwaysCompleteAnimation, shouldDisableScalingTranslations, speed, startScroll, targetElement, translateX, translateY, ...rest } = props;
    return {
        parallaxProps: removeUndefinedObjectKeys({
            disabled,
            easing,
            endScroll,
            onChange,
            onEnter,
            onExit,
            onProgressChange,
            opacity,
            rootMargin,
            rotate,
            rotateX,
            rotateY,
            rotateZ,
            scale,
            scaleX,
            scaleY,
            scaleZ,
            shouldAlwaysCompleteAnimation,
            shouldDisableScalingTranslations,
            speed,
            startScroll,
            targetElement,
            translateX,
            translateY
        }),
        rest
    };
}
//#endregion
//#region src/components/Parallax/hooks.ts
function useVerifyController(controller) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        const isServer = ("TURBOPACK compile-time value", "undefined") === "undefined";
        const isInstance = controller instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parallax$2d$controller$2f$dist$2f$parallax$2d$controller$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ParallaxController"];
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
    }, [
        controller
    ]);
}
//#endregion
//#region src/context/ParallaxContext.ts
const ParallaxContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createContext(null);
//#endregion
//#region src/hooks/useParallaxController.ts
function useParallaxController() {
    const parallaxController = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useContext"])(ParallaxContext);
    if ("TURBOPACK compile-time truthy", 1) return null;
    //TURBOPACK unreachable
    ;
}
//#endregion
//#region src/hooks/useParallax.ts
function useParallax(props) {
    const controller = useParallaxController();
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    const { parallaxProps } = getIsolatedParallaxProps(props);
    useVerifyController(controller);
    const [element, setElement] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        let newElement;
        if (ref.current instanceof HTMLElement) {
            const options = {
                el: ref.current,
                props: parallaxProps
            };
            newElement = controller === null || controller === void 0 ? void 0 : controller.createElement(options);
            setElement(newElement);
        } else throw new Error("You must assign the ref returned by the useParallax() hook to an HTML Element.");
        return ()=>{
            if (newElement) controller === null || controller === void 0 || controller.removeElementById(newElement.id);
        };
    }, []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        if (element) if (props.disabled) {
            controller === null || controller === void 0 || controller.resetElementStyles(element);
            controller === null || controller === void 0 || controller.updateElementPropsById(element.id, parallaxProps);
        } else controller === null || controller === void 0 || controller.updateElementPropsById(element.id, parallaxProps);
    }, [
        props.disabled,
        props.easing,
        props.endScroll,
        props.onChange,
        props.onEnter,
        props.onExit,
        props.onProgressChange,
        props.opacity,
        props.rootMargin,
        props.rotate,
        props.rotateX,
        props.rotateY,
        props.rotateZ,
        props.scale,
        props.scaleX,
        props.scaleY,
        props.scaleZ,
        props.shouldAlwaysCompleteAnimation,
        props.shouldDisableScalingTranslations,
        props.speed,
        props.startScroll,
        props.targetElement,
        props.translateX,
        props.translateY
    ]);
    return {
        ref,
        controller,
        element
    };
}
//#endregion
//#region src/components/Parallax/Parallax.tsx
function Parallax(props) {
    const { parallaxProps, rest } = getIsolatedParallaxProps(props);
    const { ref } = useParallax(parallaxProps);
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        ref,
        ...rest
    }, props.children);
}
//#endregion
//#region src/components/ParallaxBanner/helpers/getExpandedStyle.ts
const FALLBACK_RECT = {
    height: 0
};
function getExpandedStyle(layer) {
    if (Array.isArray(layer.translateY)) {
        const translateYStart = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parallax$2d$controller$2f$dist$2f$parallax$2d$controller$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseValueAndUnit"])(layer.translateY[0]);
        const translateYEnd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parallax$2d$controller$2f$dist$2f$parallax$2d$controller$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseValueAndUnit"])(layer.translateY[1]);
        if (translateYStart.unit === "px" && translateYEnd.unit === "px") return {
            top: `${Math.abs(translateYEnd.value) * -1}px`,
            bottom: `${Math.abs(translateYStart.value) * -1}px`
        };
        if (translateYStart.unit === "%" && translateYEnd.unit === "%") {
            var _layer$targetElement$, _layer$targetElement;
            const clientRect = (_layer$targetElement$ = (_layer$targetElement = layer.targetElement) === null || _layer$targetElement === void 0 ? void 0 : _layer$targetElement.getBoundingClientRect()) !== null && _layer$targetElement$ !== void 0 ? _layer$targetElement$ : FALLBACK_RECT;
            const top = Math.abs(clientRect.height * .01 * translateYEnd.value) * -1;
            const bottom = Math.abs(clientRect.height * .01 * translateYStart.value) * -1;
            return {
                top: `${top}px`,
                bottom: `${bottom}px`
            };
        }
    }
    if (layer.speed) {
        const speed = layer.speed || 0;
        const absSpeed = Math.abs(speed) * 10 * -1;
        return {
            top: `${absSpeed}px`,
            bottom: `${absSpeed}px`
        };
    }
    return {};
}
//#endregion
//#region src/components/ParallaxBanner/helpers/getImageStyle.ts
function getImageStyle(layer) {
    return layer.image ? {
        backgroundImage: `url(${layer.image})`,
        backgroundPosition: "center",
        backgroundSize: "cover"
    } : {};
}
//#endregion
//#region src/components/ParallaxBanner/components/ParallaxBannerLayer.tsx
const absoluteStyle = {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
};
const ParallaxBannerLayer = (props)=>{
    const { parallaxProps, rest } = getIsolatedParallaxProps(props);
    const { children, disabled, style, expanded = true, image, testId, ...divProps } = rest;
    const imageStyle = getImageStyle(props);
    const expandedStyle = expanded ? getExpandedStyle(props) : {};
    const parallax = useParallax({
        targetElement: props.targetElement,
        shouldDisableScalingTranslations: true,
        ...parallaxProps
    });
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        "data-testid": testId,
        ref: parallax.ref,
        style: {
            ...imageStyle,
            ...absoluteStyle,
            ...expandedStyle,
            ...style
        },
        ...divProps
    }, rest.children);
};
//#endregion
//#region src/components/ParallaxBanner/ParallaxBanner.tsx
const containerStyle = {
    position: "relative",
    overflow: "hidden",
    width: "100%"
};
const ParallaxBanner = (props)=>{
    const [targetElement, setTargetElement] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(null);
    const containerRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        setTargetElement(containerRef.current);
    }, []);
    const { disabled: disableAllLayers, style: rootStyle, layers = [], ...rootRest } = props;
    function renderLayers() {
        if (targetElement) {
            if (layers && layers.length > 0) return layers.map((layer, i)=>/* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement(ParallaxBannerLayer, {
                    ...layer,
                    targetElement,
                    key: `layer-${i}`,
                    testId: `layer-${i}`
                }));
        }
        return null;
    }
    function renderChildren() {
        if (targetElement) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].Children.map(props.children, (child)=>{
            const item = child;
            if ((item === null || item === void 0 ? void 0 : item.type) === ParallaxBannerLayer) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].cloneElement(item, {
                targetElement
            });
            return child;
        });
        return null;
    }
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        ref: containerRef,
        style: {
            ...containerStyle,
            ...rootStyle
        },
        ...rootRest
    }, renderLayers(), renderChildren());
};
//#endregion
//#region src/components/ParallaxProvider/helpers.ts
const createController = (options)=>{
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return null;
};
//#endregion
//#region src/components/ParallaxProvider/ParallaxProvider.tsx
function ParallaxProvider(props) {
    const controller = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    if (!controller.current) controller.current = createController({
        scrollAxis: props.scrollAxis || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parallax$2d$controller$2f$dist$2f$parallax$2d$controller$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ScrollAxis"].vertical,
        scrollContainer: props.scrollContainer,
        disabled: props.isDisabled
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        if (props.scrollContainer && controller.current) controller.current.updateScrollContainer(props.scrollContainer);
    }, [
        props.scrollContainer
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        if (props.isDisabled && controller.current) controller.current.disableParallaxController();
        if (!props.isDisabled && controller.current) controller.current.enableParallaxController();
    }, [
        props.isDisabled
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        return ()=>{
            var _controller$current;
            controller === null || controller === void 0 || (_controller$current = controller.current) === null || _controller$current === void 0 || _controller$current.destroy();
        };
    }, []);
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement(ParallaxContext.Provider, {
        value: controller.current
    }, props.children);
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return {
        default: obj
    };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }
    newObj.default = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}
exports._ = _interop_require_wildcard;
}),
"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports._ = _interop_require_default;
}),
"[project]/node_modules/motion-utils/dist/es/clamp.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clamp",
    ()=>clamp
]);
const clamp = (min, max, v)=>{
    if (v > max) return max;
    if (v < min) return min;
    return v;
};
;
}),
"[project]/node_modules/motion-utils/dist/es/format-error-message.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatErrorMessage",
    ()=>formatErrorMessage
]);
function formatErrorMessage(message, errorCode) {
    return errorCode ? `${message}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${errorCode}` : message;
}
;
}),
"[project]/node_modules/motion-utils/dist/es/errors.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "invariant",
    ()=>invariant,
    "warning",
    ()=>warning
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$format$2d$error$2d$message$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/format-error-message.mjs [app-ssr] (ecmascript)");
;
let warning = ()=>{};
let invariant = ()=>{};
if ("TURBOPACK compile-time truthy", 1) {
    warning = (check, message, errorCode)=>{
        if (!check && typeof console !== "undefined") {
            console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$format$2d$error$2d$message$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatErrorMessage"])(message, errorCode));
        }
    };
    invariant = (check, message, errorCode)=>{
        if (!check) {
            throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$format$2d$error$2d$message$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatErrorMessage"])(message, errorCode));
        }
    };
}
;
}),
"[project]/node_modules/motion-utils/dist/es/is-numerical-string.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"
 */ __turbopack_context__.s([
    "isNumericalString",
    ()=>isNumericalString
]);
const isNumericalString = (v)=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);
;
}),
"[project]/node_modules/motion-utils/dist/es/noop.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*#__NO_SIDE_EFFECTS__*/ __turbopack_context__.s([
    "noop",
    ()=>noop
]);
const noop = (any)=>any;
;
}),
"[project]/node_modules/motion-utils/dist/es/global-config.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MotionGlobalConfig",
    ()=>MotionGlobalConfig
]);
const MotionGlobalConfig = {};
;
}),
"[project]/node_modules/motion-utils/dist/es/is-zero-value-string.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Check if the value is a zero value string like "0px" or "0%"
 */ __turbopack_context__.s([
    "isZeroValueString",
    ()=>isZeroValueString
]);
const isZeroValueString = (v)=>/^0[^.\s]+$/u.test(v);
;
}),
"[project]/node_modules/motion-utils/dist/es/warn-once.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "hasWarned",
    ()=>hasWarned,
    "warnOnce",
    ()=>warnOnce
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$format$2d$error$2d$message$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/format-error-message.mjs [app-ssr] (ecmascript)");
;
const warned = new Set();
function hasWarned(message) {
    return warned.has(message);
}
function warnOnce(condition, message, errorCode) {
    if (condition || warned.has(message)) return;
    console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$format$2d$error$2d$message$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatErrorMessage"])(message, errorCode));
    warned.add(message);
}
;
}),
"[project]/node_modules/motion-utils/dist/es/array.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addUniqueItem",
    ()=>addUniqueItem,
    "moveItem",
    ()=>moveItem,
    "removeItem",
    ()=>removeItem
]);
function addUniqueItem(arr, item) {
    if (arr.indexOf(item) === -1) arr.push(item);
}
function removeItem(arr, item) {
    const index = arr.indexOf(item);
    if (index > -1) arr.splice(index, 1);
}
// Adapted from array-move
function moveItem([...arr], fromIndex, toIndex) {
    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;
    if (startIndex >= 0 && startIndex < arr.length) {
        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;
        const [item] = arr.splice(fromIndex, 1);
        arr.splice(endIndex, 0, item);
    }
    return arr;
}
;
}),
"[project]/node_modules/motion-utils/dist/es/subscription-manager.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SubscriptionManager",
    ()=>SubscriptionManager
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$array$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/array.mjs [app-ssr] (ecmascript)");
;
class SubscriptionManager {
    constructor(){
        this.subscriptions = [];
    }
    add(handler) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$array$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addUniqueItem"])(this.subscriptions, handler);
        return ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$array$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["removeItem"])(this.subscriptions, handler);
    }
    notify(a, b, c) {
        const numSubscriptions = this.subscriptions.length;
        if (!numSubscriptions) return;
        if (numSubscriptions === 1) {
            /**
             * If there's only a single handler we can just call it without invoking a loop.
             */ this.subscriptions[0](a, b, c);
        } else {
            for(let i = 0; i < numSubscriptions; i++){
                /**
                 * Check whether the handler exists before firing as it's possible
                 * the subscriptions were modified during this loop running.
                 */ const handler = this.subscriptions[i];
                handler && handler(a, b, c);
            }
        }
    }
    getSize() {
        return this.subscriptions.length;
    }
    clear() {
        this.subscriptions.length = 0;
    }
}
;
}),
"[project]/node_modules/motion-utils/dist/es/velocity-per-second.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
  Convert velocity into velocity per second

  @param [number]: Unit per frame
  @param [number]: Frame duration in ms
*/ __turbopack_context__.s([
    "velocityPerSecond",
    ()=>velocityPerSecond
]);
function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1000 / frameDuration) : 0;
}
;
}),
"[project]/node_modules/motion-utils/dist/es/pipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Pipe
 * Compose other transformers to run linearily
 * pipe(min(20), max(40))
 * @param  {...functions} transformers
 * @return {function}
 */ __turbopack_context__.s([
    "pipe",
    ()=>pipe
]);
const combineFunctions = (a, b)=>(v)=>b(a(v));
const pipe = (...transformers)=>transformers.reduce(combineFunctions);
;
}),
"[project]/node_modules/motion-utils/dist/es/time-conversion.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Converts seconds to milliseconds
 *
 * @param seconds - Time in seconds.
 * @return milliseconds - Converted time in milliseconds.
 */ /*#__NO_SIDE_EFFECTS__*/ __turbopack_context__.s([
    "millisecondsToSeconds",
    ()=>millisecondsToSeconds,
    "secondsToMilliseconds",
    ()=>secondsToMilliseconds
]);
const secondsToMilliseconds = (seconds)=>seconds * 1000;
/*#__NO_SIDE_EFFECTS__*/ const millisecondsToSeconds = (milliseconds)=>milliseconds / 1000;
;
}),
"[project]/node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cubicBezier",
    ()=>cubicBezier
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$noop$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/noop.mjs [app-ssr] (ecmascript)");
;
/*
  Bezier function generator
  This has been modified from Gaëtan Renaudeau's BezierEasing
  https://github.com/gre/bezier-easing/blob/master/src/index.js
  https://github.com/gre/bezier-easing/blob/master/LICENSE
  
  I've removed the newtonRaphsonIterate algo because in benchmarking it
  wasn't noticeably faster than binarySubdivision, indeed removing it
  usually improved times, depending on the curve.
  I also removed the lookup table, as for the added bundle size and loop we're
  only cutting ~4 or so subdivision iterations. I bumped the max iterations up
  to 12 to compensate and this still tended to be faster for no perceivable
  loss in accuracy.
  Usage
    const easeOut = cubicBezier(.17,.67,.83,.67);
    const x = easeOut(0.5); // returns 0.627...
*/ // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
const calcBezier = (t, a1, a2)=>(((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;
const subdivisionPrecision = 0.0000001;
const subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i = 0;
    do {
        currentT = lowerBound + (upperBound - lowerBound) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - x;
        if (currentX > 0.0) {
            upperBound = currentT;
        } else {
            lowerBound = currentT;
        }
    }while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations)
    return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
    // If this is a linear gradient, return linear easing
    if (mX1 === mY1 && mX2 === mY2) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$noop$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["noop"];
    const getTForX = (aX)=>binarySubdivide(aX, 0, 1, mX1, mX2);
    // If animation is at start/end, return t without easing
    return (t)=>t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}
;
}),
"[project]/node_modules/motion-utils/dist/es/easing/ease.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "easeIn",
    ()=>easeIn,
    "easeInOut",
    ()=>easeInOut,
    "easeOut",
    ()=>easeOut
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs [app-ssr] (ecmascript)");
;
const easeIn = /*@__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cubicBezier"])(0.42, 0, 1, 1);
const easeOut = /*@__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cubicBezier"])(0, 0, 0.58, 1);
const easeInOut = /*@__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cubicBezier"])(0.42, 0, 0.58, 1);
;
}),
"[project]/node_modules/motion-utils/dist/es/easing/utils/is-easing-array.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isEasingArray",
    ()=>isEasingArray
]);
const isEasingArray = (ease)=>{
    return Array.isArray(ease) && typeof ease[0] !== "number";
};
;
}),
"[project]/node_modules/motion-utils/dist/es/easing/modifiers/mirror.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Accepts an easing function and returns a new one that outputs mirrored values for
// the second half of the animation. Turns easeIn into easeInOut.
__turbopack_context__.s([
    "mirrorEasing",
    ()=>mirrorEasing
]);
const mirrorEasing = (easing)=>(p)=>p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
;
}),
"[project]/node_modules/motion-utils/dist/es/easing/modifiers/reverse.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Accepts an easing function and returns a new one that outputs reversed values.
// Turns easeIn into easeOut.
__turbopack_context__.s([
    "reverseEasing",
    ()=>reverseEasing
]);
const reverseEasing = (easing)=>(p)=>1 - easing(1 - p);
;
}),
"[project]/node_modules/motion-utils/dist/es/easing/back.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "backIn",
    ()=>backIn,
    "backInOut",
    ()=>backInOut,
    "backOut",
    ()=>backOut
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$mirror$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/modifiers/mirror.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$reverse$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/modifiers/reverse.mjs [app-ssr] (ecmascript)");
;
;
;
const backOut = /*@__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cubicBezier"])(0.33, 1.53, 0.69, 0.99);
const backIn = /*@__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$reverse$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["reverseEasing"])(backOut);
const backInOut = /*@__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$mirror$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mirrorEasing"])(backIn);
;
}),
"[project]/node_modules/motion-utils/dist/es/easing/anticipate.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "anticipate",
    ()=>anticipate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$back$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/back.mjs [app-ssr] (ecmascript)");
;
const anticipate = (p)=>(p *= 2) < 1 ? 0.5 * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$back$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["backIn"])(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
;
}),
"[project]/node_modules/motion-utils/dist/es/easing/circ.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "circIn",
    ()=>circIn,
    "circInOut",
    ()=>circInOut,
    "circOut",
    ()=>circOut
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$mirror$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/modifiers/mirror.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$reverse$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/modifiers/reverse.mjs [app-ssr] (ecmascript)");
;
;
const circIn = (p)=>1 - Math.sin(Math.acos(p));
const circOut = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$reverse$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["reverseEasing"])(circIn);
const circInOut = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$mirror$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mirrorEasing"])(circIn);
;
}),
"[project]/node_modules/motion-utils/dist/es/easing/utils/is-bezier-definition.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isBezierDefinition",
    ()=>isBezierDefinition
]);
const isBezierDefinition = (easing)=>Array.isArray(easing) && typeof easing[0] === "number";
;
}),
"[project]/node_modules/motion-utils/dist/es/easing/utils/map.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "easingDefinitionToFunction",
    ()=>easingDefinitionToFunction
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/errors.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$noop$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/noop.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$anticipate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/anticipate.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$back$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/back.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$circ$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/circ.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$ease$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/ease.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$utils$2f$is$2d$bezier$2d$definition$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/utils/is-bezier-definition.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
const easingLookup = {
    linear: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$noop$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["noop"],
    easeIn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$ease$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["easeIn"],
    easeInOut: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$ease$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["easeInOut"],
    easeOut: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$ease$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["easeOut"],
    circIn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$circ$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["circIn"],
    circInOut: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$circ$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["circInOut"],
    circOut: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$circ$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["circOut"],
    backIn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$back$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["backIn"],
    backInOut: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$back$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["backInOut"],
    backOut: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$back$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["backOut"],
    anticipate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$anticipate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["anticipate"]
};
const isValidEasing = (easing)=>{
    return typeof easing === "string";
};
const easingDefinitionToFunction = (definition)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$utils$2f$is$2d$bezier$2d$definition$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBezierDefinition"])(definition)) {
        // If cubic bezier definition, create bezier curve
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["invariant"])(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`, "cubic-bezier-length");
        const [x1, y1, x2, y2] = definition;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cubicBezier"])(x1, y1, x2, y2);
    } else if (isValidEasing(definition)) {
        // Else lookup from table
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["invariant"])(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`, "invalid-easing-type");
        return easingLookup[definition];
    }
    return definition;
};
;
}),
"[project]/node_modules/motion-utils/dist/es/progress.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
  Progress within given range

  Given a lower limit and an upper limit, we return the progress
  (expressed as a number 0-1) represented by the given value, and
  limit that progress to within 0-1.

  @param [number]: Lower limit
  @param [number]: Upper limit
  @param [number]: Value to find progress within given range
  @return [number]: Progress of value within range as expressed 0-1
*/ /*#__NO_SIDE_EFFECTS__*/ __turbopack_context__.s([
    "progress",
    ()=>progress
]);
const progress = (from, to, value)=>{
    const toFromDifference = to - from;
    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
;
}),
"[project]/node_modules/motion-utils/dist/es/memo.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*#__NO_SIDE_EFFECTS__*/ __turbopack_context__.s([
    "memo",
    ()=>memo
]);
function memo(callback) {
    let result;
    return ()=>{
        if (result === undefined) result = callback();
        return result;
    };
}
;
}),
"[project]/node_modules/motion-utils/dist/es/is-object.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isObject",
    ()=>isObject
]);
function isObject(value) {
    return typeof value === "object" && value !== null;
}
;
}),
"[project]/node_modules/@fortawesome/react-fontawesome/dist/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FontAwesomeIcon",
    ()=>FontAwesomeIcon,
    "FontAwesomeLayers",
    ()=>FontAwesomeLayers,
    "LayersCounter",
    ()=>LayersCounter,
    "LayersText",
    ()=>LayersText
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$fortawesome$2f$fontawesome$2d$svg$2d$core$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@fortawesome/fontawesome-svg-core/index.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
;
;
;
// src/components/FontAwesomeIcon.tsx
// src/utils/camelize.ts
function _isNumerical(object) {
    object = object - 0;
    return object === object;
}
function camelize(string) {
    if (_isNumerical(string)) {
        return string;
    }
    string = string.replace(/[_-]+(.)?/g, (_, chr)=>{
        return chr ? chr.toUpperCase() : "";
    });
    return string.charAt(0).toLowerCase() + string.slice(1);
}
// src/converter.ts
function capitalize(val) {
    return val.charAt(0).toUpperCase() + val.slice(1);
}
var styleCache = /* @__PURE__ */ new Map();
var STYLE_CACHE_LIMIT = 1e3;
function styleToObject(style) {
    if (styleCache.has(style)) {
        return styleCache.get(style);
    }
    const result = {};
    let start = 0;
    const len = style.length;
    while(start < len){
        const semicolonIndex = style.indexOf(";", start);
        const end = semicolonIndex === -1 ? len : semicolonIndex;
        const pair = style.slice(start, end).trim();
        if (pair) {
            const colonIndex = pair.indexOf(":");
            if (colonIndex > 0) {
                const rawProp = pair.slice(0, colonIndex).trim();
                const value = pair.slice(colonIndex + 1).trim();
                if (rawProp && value) {
                    const prop = camelize(rawProp);
                    result[prop.startsWith("webkit") ? capitalize(prop) : prop] = value;
                }
            }
        }
        start = end + 1;
    }
    if (styleCache.size === STYLE_CACHE_LIMIT) {
        const oldestKey = styleCache.keys().next().value;
        if (oldestKey) {
            styleCache.delete(oldestKey);
        }
    }
    styleCache.set(style, result);
    return result;
}
function convert(createElement, element, extraProps = {}) {
    if (typeof element === "string") {
        return element;
    }
    const children = (element.children || []).map((child)=>{
        return convert(createElement, child);
    });
    const elementAttributes = element.attributes || {};
    const attrs = {};
    for (const [key, val] of Object.entries(elementAttributes)){
        switch(true){
            case key === "class":
                {
                    attrs.className = val;
                    break;
                }
            case key === "style":
                {
                    attrs.style = styleToObject(String(val));
                    break;
                }
            case key.startsWith("aria-"):
            case key.startsWith("data-"):
                {
                    attrs[key.toLowerCase()] = val;
                    break;
                }
            default:
                {
                    attrs[camelize(key)] = val;
                }
        }
    }
    const { style: existingStyle, "aria-label": ariaLabel, ...remaining } = extraProps;
    if (existingStyle) {
        attrs.style = attrs.style ? {
            ...attrs.style,
            ...existingStyle
        } : existingStyle;
    }
    if (ariaLabel) {
        attrs["aria-label"] = ariaLabel;
        attrs["aria-hidden"] = "false";
    }
    return createElement(element.tag, {
        ...remaining,
        ...attrs
    }, ...children);
}
var makeReactConverter = convert.bind(null, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement);
var useAccessibilityId = (id, hasAccessibleProps)=>{
    const generatedId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useId"])();
    return id || (hasAccessibleProps ? generatedId : void 0);
};
// src/logger.ts
var Logger = class {
    constructor(scope = "react-fontawesome"){
        this.enabled = false;
        let IS_DEV = false;
        try {
            IS_DEV = typeof process !== "undefined" && ("TURBOPACK compile-time value", "development") === "development";
        } catch  {}
        this.scope = scope;
        this.enabled = IS_DEV;
    }
    /**
   * Logs messages to the console if not in production.
   * @param args - The message and/or data to log.
   */ log(...args) {
        if (!this.enabled) return;
        console.log(`[${this.scope}]`, ...args);
    }
    /**
   * Logs warnings to the console if not in production.
   * @param args - The warning message and/or data to log.
   */ warn(...args) {
        if (!this.enabled) return;
        console.warn(`[${this.scope}]`, ...args);
    }
    /**
   * Logs errors to the console if not in production.
   * @param args - The error message and/or data to log.
   */ error(...args) {
        if (!this.enabled) return;
        console.error(`[${this.scope}]`, ...args);
    }
};
typeof process !== "undefined" && process.env.FA_VERSION || "7.0.0";
var SVG_CORE_VERSION = "searchPseudoElementsFullScan" in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$fortawesome$2f$fontawesome$2d$svg$2d$core$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["config"] ? "7.0.0" : "6.0.0";
var IS_VERSION_7_OR_LATER = Number.parseInt(SVG_CORE_VERSION) >= 7;
var DEFAULT_CLASSNAME_PREFIX = "fa";
var ANIMATION_CLASSES = {
    beat: "fa-beat",
    fade: "fa-fade",
    beatFade: "fa-beat-fade",
    bounce: "fa-bounce",
    shake: "fa-shake",
    spin: "fa-spin",
    spinPulse: "fa-spin-pulse",
    spinReverse: "fa-spin-reverse",
    pulse: "fa-pulse"
};
var PULL_CLASSES = {
    left: "fa-pull-left",
    right: "fa-pull-right"
};
var ROTATE_CLASSES = {
    "90": "fa-rotate-90",
    "180": "fa-rotate-180",
    "270": "fa-rotate-270"
};
var SIZE_CLASSES = {
    "2xs": "fa-2xs",
    xs: "fa-xs",
    sm: "fa-sm",
    lg: "fa-lg",
    xl: "fa-xl",
    "2xl": "fa-2xl",
    "1x": "fa-1x",
    "2x": "fa-2x",
    "3x": "fa-3x",
    "4x": "fa-4x",
    "5x": "fa-5x",
    "6x": "fa-6x",
    "7x": "fa-7x",
    "8x": "fa-8x",
    "9x": "fa-9x",
    "10x": "fa-10x"
};
var STYLE_CLASSES = {
    border: "fa-border",
    /** @deprecated */ fixedWidth: "fa-fw",
    flip: "fa-flip",
    flipHorizontal: "fa-flip-horizontal",
    flipVertical: "fa-flip-vertical",
    inverse: "fa-inverse",
    rotateBy: "fa-rotate-by",
    swapOpacity: "fa-swap-opacity",
    widthAuto: "fa-width-auto"
};
var LAYER_CLASSES = {
    default: "fa-layers"
};
// src/utils/get-class-list-from-props.ts
function withPrefix(cls) {
    const prefix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$fortawesome$2f$fontawesome$2d$svg$2d$core$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["config"].cssPrefix || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$fortawesome$2f$fontawesome$2d$svg$2d$core$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["config"].familyPrefix || DEFAULT_CLASSNAME_PREFIX;
    return prefix === DEFAULT_CLASSNAME_PREFIX ? cls : cls.replace(new RegExp(`(?<=^|\\s)${DEFAULT_CLASSNAME_PREFIX}-`, "g"), `${prefix}-`);
}
function getClassListFromProps(props) {
    const { beat, fade, beatFade, bounce, shake, spin, spinPulse, spinReverse, pulse, fixedWidth, inverse, border, flip, size, rotation, pull, swapOpacity, rotateBy, widthAuto, className } = props;
    const result = [];
    if (className) result.push(...className.split(" "));
    if (beat) result.push(ANIMATION_CLASSES.beat);
    if (fade) result.push(ANIMATION_CLASSES.fade);
    if (beatFade) result.push(ANIMATION_CLASSES.beatFade);
    if (bounce) result.push(ANIMATION_CLASSES.bounce);
    if (shake) result.push(ANIMATION_CLASSES.shake);
    if (spin) result.push(ANIMATION_CLASSES.spin);
    if (spinReverse) result.push(ANIMATION_CLASSES.spinReverse);
    if (spinPulse) result.push(ANIMATION_CLASSES.spinPulse);
    if (pulse) result.push(ANIMATION_CLASSES.pulse);
    if (fixedWidth) result.push(STYLE_CLASSES.fixedWidth);
    if (inverse) result.push(STYLE_CLASSES.inverse);
    if (border) result.push(STYLE_CLASSES.border);
    if (flip === true) result.push(STYLE_CLASSES.flip);
    if (flip === "horizontal" || flip === "both") {
        result.push(STYLE_CLASSES.flipHorizontal);
    }
    if (flip === "vertical" || flip === "both") {
        result.push(STYLE_CLASSES.flipVertical);
    }
    if (size !== void 0 && size !== null) result.push(SIZE_CLASSES[size]);
    if (rotation !== void 0 && rotation !== null && rotation !== 0) {
        result.push(ROTATE_CLASSES[rotation]);
    }
    if (pull !== void 0 && pull !== null) result.push(PULL_CLASSES[pull]);
    if (swapOpacity) result.push(STYLE_CLASSES.swapOpacity);
    if (!IS_VERSION_7_OR_LATER) return result;
    if (rotateBy) result.push(STYLE_CLASSES.rotateBy);
    if (widthAuto) result.push(STYLE_CLASSES.widthAuto);
    const prefix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$fortawesome$2f$fontawesome$2d$svg$2d$core$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["config"].cssPrefix || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$fortawesome$2f$fontawesome$2d$svg$2d$core$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["config"].familyPrefix || DEFAULT_CLASSNAME_PREFIX;
    return prefix === DEFAULT_CLASSNAME_PREFIX ? result : // TODO: see if we can achieve custom prefix support without iterating
    // eslint-disable-next-line unicorn/no-array-callback-reference
    result.map(withPrefix);
}
var isIconDefinition = (icon)=>typeof icon === "object" && "icon" in icon && !!icon.icon;
function normalizeIconArgs(icon) {
    if (!icon) {
        return void 0;
    }
    if (isIconDefinition(icon)) {
        return icon;
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$fortawesome$2f$fontawesome$2d$svg$2d$core$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"].icon(icon);
}
// src/utils/typed-object-keys.ts
function typedObjectKeys(obj) {
    return Object.keys(obj);
}
// src/components/FontAwesomeIcon.tsx
var logger = new Logger("FontAwesomeIcon");
var DEFAULT_PROPS = {
    border: false,
    className: "",
    mask: void 0,
    maskId: void 0,
    fixedWidth: false,
    inverse: false,
    flip: false,
    icon: void 0,
    listItem: false,
    pull: void 0,
    pulse: false,
    rotation: void 0,
    rotateBy: false,
    size: void 0,
    spin: false,
    spinPulse: false,
    spinReverse: false,
    beat: false,
    fade: false,
    beatFade: false,
    bounce: false,
    shake: false,
    symbol: false,
    title: "",
    titleId: void 0,
    transform: void 0,
    swapOpacity: false,
    widthAuto: false
};
var DEFAULT_PROP_KEYS = new Set(Object.keys(DEFAULT_PROPS));
var FontAwesomeIcon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].forwardRef((props, ref)=>{
    const allProps = {
        ...DEFAULT_PROPS,
        ...props
    };
    const { icon: iconArgs, mask: maskArgs, symbol, title, titleId: titleIdFromProps, maskId: maskIdFromProps, transform } = allProps;
    const maskId = useAccessibilityId(maskIdFromProps, Boolean(maskArgs));
    const titleId = useAccessibilityId(titleIdFromProps, Boolean(title));
    const iconLookup = normalizeIconArgs(iconArgs);
    if (!iconLookup) {
        logger.error("Icon lookup is undefined", iconArgs);
        return null;
    }
    const classList = getClassListFromProps(allProps);
    const transformProps = typeof transform === "string" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$fortawesome$2f$fontawesome$2d$svg$2d$core$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"].transform(transform) : transform;
    const normalizedMaskArgs = normalizeIconArgs(maskArgs);
    const renderedIcon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$fortawesome$2f$fontawesome$2d$svg$2d$core$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["icon"])(iconLookup, {
        ...classList.length > 0 && {
            classes: classList
        },
        ...transformProps && {
            transform: transformProps
        },
        ...normalizedMaskArgs && {
            mask: normalizedMaskArgs
        },
        symbol,
        title,
        titleId,
        maskId
    });
    if (!renderedIcon) {
        logger.error("Could not find icon", iconLookup);
        return null;
    }
    const { abstract } = renderedIcon;
    const extraProps = {
        ref
    };
    for (const key of typedObjectKeys(allProps)){
        if (DEFAULT_PROP_KEYS.has(key)) {
            continue;
        }
        extraProps[key] = allProps[key];
    }
    return makeReactConverter(abstract[0], extraProps);
});
FontAwesomeIcon.displayName = "FontAwesomeIcon";
var DEFAULT_CLASSNAMES = `${LAYER_CLASSES.default} ${STYLE_CLASSES.fixedWidth}`;
var FontAwesomeLayers = ({ children, className, size, ...attributes })=>{
    const prefixedDefaultClasses = withPrefix(DEFAULT_CLASSNAMES);
    const classes = className ? `${prefixedDefaultClasses} ${className}` : prefixedDefaultClasses;
    const element = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("span", {
        ...attributes,
        className: classes,
        children
    });
    if (size) {
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("div", {
            className: withPrefix(`fa-${size}`),
            children: element
        });
    }
    return element;
};
var LayersText = ({ text: text$1, className, inverse, transform, style, ...attributes })=>{
    const textAbstractElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useMemo"])(()=>{
        const textObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$fortawesome$2f$fontawesome$2d$svg$2d$core$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["text"])(text$1, {
            classes: [
                ...className?.split(" ") || [],
                ...inverse ? [
                    STYLE_CLASSES.inverse
                ] : []
            ],
            transform: typeof transform === "string" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$fortawesome$2f$fontawesome$2d$svg$2d$core$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"].transform(transform) : transform
        });
        return textObject.abstract[0];
    }, [
        text$1,
        transform,
        className,
        inverse
    ]);
    return makeReactConverter(textAbstractElement, {
        ...attributes,
        style
    });
};
var LayersCounter = ({ count, className, style, ...attributes })=>{
    const counterAbstractElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useMemo"])(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$fortawesome$2f$fontawesome$2d$svg$2d$core$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["counter"])(count, {
            classes: className?.split(" ")
        }).abstract[0], [
        count,
        className
    ]);
    return makeReactConverter(counterAbstractElement, {
        ...attributes,
        style
    });
};
;
}),
];

//# sourceMappingURL=node_modules_3e9e9a86._.js.map